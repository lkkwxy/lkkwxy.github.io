<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="李坤坤">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="李坤坤">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>李坤坤</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李坤坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Kingfisher源码解析之使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-07T00:00:00+08:00">2019-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><h5 id="1-1-通过-Resource-设置图片"><a href="#1-1-通过-Resource-设置图片" class="headerlink" title="1.1 通过 Resource 设置图片"></a>1.1 通过 Resource 设置图片</h5><p>Kingfisher 中内置的 ImageResource 和 URL 实现了 Resource 协议，ImageResource 和 URL 的区别是 ImageResource 可自定义 cacheKey。</p>
<ul>
<li>URL 设置图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;test&#x2F;image.jpg&quot;)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url)</span></pre></td></tr></table></figure>

<ul>
<li>ImageResource</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let imageResource &#x3D; ImageResource(downloadURL: url, cacheKey: &quot;custom_cache_key&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: imageResource)</span></pre></td></tr></table></figure>

<h5 id="1-2-通过-ImageDataProvider-设置图片"><a href="#1-2-通过-ImageDataProvider-设置图片" class="headerlink" title="1.2 通过 ImageDataProvider 设置图片"></a>1.2 通过 ImageDataProvider 设置图片</h5><p>Kingfisher 内置了 LocalFileImageDataProvider，Base64ImageDataProvider，RawImageDataProvider 三种 ImageDataProvider。</p>
<ul>
<li>LocalFileImageDataProvider</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let fileUrl &#x3D; Bundle.main.url(forResource: &quot;image&quot;, withExtension: &quot;jpg&quot;)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let imageDataProvider &#x3D;  LocalFileImageDataProvider(fileURL: fileUrl)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: imageDataProvider)</span></pre></td></tr></table></figure>

<ul>
<li>Base64ImageDataProvider</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let base64String &#x3D; &quot;....&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let base64ImageDataProvider &#x3D; Base64ImageDataProvider(base64String: base64String, cacheKey: &quot;base64_cache_key&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: base64ImageDataProvider)</span></pre></td></tr></table></figure>

<ul>
<li>RawImageDataProvider</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let data &#x3D; Data()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let dataImageDataProvider &#x3D; RawImageDataProvider(data: data, cacheKey: &quot;data_cache_key&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: dataImageDataProvider)</span></pre></td></tr></table></figure>

<ul>
<li>自定义 ImageDataProvider</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public struct FileNameImageDataProvider : ImageDataProvider &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public let cacheKey: String</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    public let fileName: String</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public init(fileName: String, cacheKey: String? &#x3D; nil) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        self.fileName &#x3D; fileName</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.cacheKey &#x3D; cacheKey ?? fileName</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    public func data(handler: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if let fileURL &#x3D; Bundle.main.url(forResource: fileName, withExtension: &quot;&quot;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            handler(Result(catching: &#123; try Data(contentsOf: fileURL) &#125;))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            let error &#x3D; NSError(domain: &quot;文件不存在&quot;, code: -1, userInfo: [&quot;fileName&quot;:fileName])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            handler(.failure(error))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">let fileNameImageDataProvider &#x3D; FileNameImageDataProvider(fileName: &quot;image.jpg&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: fileNameImageDataProvider)</span></pre></td></tr></table></figure>

<h5 id="1-3-展示-placeholder"><a href="#1-3-展示-placeholder" class="headerlink" title="1.3 展示 placeholder"></a>1.3 展示 placeholder</h5><ul>
<li>使用 UIImage 设置 placeholder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let placeholderImage &#x3D; UIImage(named: &quot;placeholder.png&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, placeholder: placeholderImage)</span></pre></td></tr></table></figure>

<ul>
<li>通过自定义 View 设置 placeholder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要使自定义View遵循Placeholder协议</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以什么都不实现，是因为当Placeholder为UIview的时候有默认实现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">class PlaceholderView: UIView, Placeholder &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">let placeholderView &#x3D; PlaceholderView()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, placeholder: placeholderView)</span></pre></td></tr></table></figure>

<h5 id="1-4-加载-GIF-图"><a href="#1-4-加载-GIF-图" class="headerlink" title="1.4 加载 GIF 图"></a>1.4 加载 GIF 图</h5><ul>
<li>通过 UIImageView 加载 GIF 图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;test&#x2F;image.gif&quot;)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url)</span></pre></td></tr></table></figure>

<ul>
<li>通过 AnimatedImageView 加载 GIF 图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;test&#x2F;image.gif&quot;)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">animatedImageView.kf.setImage(with: url)</span></pre></td></tr></table></figure>

<p>上面二者的区别请参考<a href="https://juejin.im/post/5de5275a6fb9a071ba2e6c77" target="_blank" rel="noopener">Kingfisher 源码解析之加载动图
</a></p>
<h5 id="1-5-设置指示器"><a href="#1-5-设置指示器" class="headerlink" title="1.5 设置指示器"></a>1.5 设置指示器</h5><ul>
<li>不使用指示器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">imageView.kf.indicatorType &#x3D; .none</span></pre></td></tr></table></figure>

<ul>
<li>使用 UIActivityIndicatorView 作为指示器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">imageView.kf.indicatorType &#x3D; .activity</span></pre></td></tr></table></figure>

<ul>
<li>使用图片作为指示器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let path &#x3D; Bundle.main.path(forResource: &quot;loader&quot;, ofType: &quot;gif&quot;)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let data &#x3D; try! Data(contentsOf: URL(fileURLWithPath: path))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">imageView.kf.indicatorType &#x3D; .image(imageData: data)</span></pre></td></tr></table></figure>

<ul>
<li>使用自定义 View 作为指示器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct CustomIndicator: Indicator &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    let view: UIView &#x3D; UIView()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    func startAnimatingView() &#123; view.isHidden &#x3D; false &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    func stopAnimatingView() &#123; view.isHidden &#x3D; true &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    init() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        view.backgroundColor &#x3D; .red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">let indicator &#x3D; CustomIndicator()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">imageView.kf.indicatorType &#x3D; .custom(indicator: indicator)</span></pre></td></tr></table></figure>

<h5 id="1-6-设置-transition"><a href="#1-6-设置-transition" class="headerlink" title="1.6 设置 transition"></a>1.6 设置 transition</h5><p>transition 用于图片加载完成之后的展示动画，有以下类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public enum ImageTransition &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 无动画</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    case none</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 相当于UIView.AnimationOptions.transitionCrossDissolve</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    case fade(TimeInterval)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 相当于UIView.AnimationOptions.transitionFlipFromLeft</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    case flipFromLeft(TimeInterval)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 相当于UIView.AnimationOptions.transitionFlipFromRight</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    case flipFromRight(TimeInterval)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 相当于UIView.AnimationOptions.transitionFlipFromTop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    case flipFromTop(TimeInterval)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 相当于UIView.AnimationOptions.transitionFlipFromBottom</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    case flipFromBottom(TimeInterval)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 自定义动画</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    case custom(duration: TimeInterval,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                 options: UIView.AnimationOptions,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">              animations: ((UIImageView, UIImage) -&gt; Void)?,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">              completion: ((Bool) -&gt; Void)?)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options: [.transition(.fade(0.2))])</span></pre></td></tr></table></figure>

<h3 id="2-Processor"><a href="#2-Processor" class="headerlink" title="2. Processor"></a>2. Processor</h3><h5 id="2-1-DefaultImageProcessor"><a href="#2-1-DefaultImageProcessor" class="headerlink" title="2.1 DefaultImageProcessor"></a>2.1 DefaultImageProcessor</h5><p>将下载的数据转换为相应的 UIImage。支持 PNG，JPEG 和 GIF 格式。</p>
<h5 id="2-2-BlendImageProcessor"><a href="#2-2-BlendImageProcessor" class="headerlink" title="2.2 BlendImageProcessor"></a>2.2 BlendImageProcessor</h5><p>修改图片的混合模式（这里不知道这么描述对不对），核心实现如下</p>
<ol>
<li>首先利用 DefaultImageProcessor 把 Data 转成 image，然后去绘制</li>
<li>获取上下文</li>
<li>为上下文填充背景色</li>
<li>调用 image.draw 函数设置混合模式</li>
<li>从上下文中获取图片为 processedImage</li>
<li>释放上下文，并返回 processedImage</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let image &#x3D; 处理之前的图片</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(size, false, scale)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let context &#x3D; UIGraphicsGetCurrentContext()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">let rect &#x3D; CGRect(origin: .zero, size: size)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">backgroundColor.setFill()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">UIRectFill(rect)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">image.draw(in: rect, blendMode: blendMode, alpha: alpha)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">let cgImage &#x3D; context.makeImage()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">let processedImage &#x3D; UIImage(cgImage: cgImage, scale: scale, orientation: image.orientation)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">UIGraphicsEndImageContext()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">return processedImage</span></pre></td></tr></table></figure>

<h5 id="2-3-OverlayImageProcessor"><a href="#2-3-OverlayImageProcessor" class="headerlink" title="2.3 OverlayImageProcessor"></a>2.3 OverlayImageProcessor</h5><p>在 image 上添加一层覆盖，其本质也是混合模式，逻辑大致同上</p>
<h5 id="2-4-BlurImageProcessor"><a href="#2-4-BlurImageProcessor" class="headerlink" title="2.4 BlurImageProcessor"></a>2.4 BlurImageProcessor</h5><p>给图片添加高斯模糊，用 vimage 实现</p>
<h5 id="2-5-RoundCornerImageProcessor"><a href="#2-5-RoundCornerImageProcessor" class="headerlink" title="2.5 RoundCornerImageProcessor"></a>2.5 RoundCornerImageProcessor</h5><p>给图片添加圆角，支持四个角进行相互组合，使用方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置四个角的圆角</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options: [.processor(RoundCornerImageProcessor(cornerRadius: 20))])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给最上角和右下角设置圆角</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options: [.processor(RoundCornerImageProcessor(cornerRadius: 20</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                                            ,roundingCorners: [.topLeft, .bottomRight]))])</span></pre></td></tr></table></figure>

<p>实现方式：利用贝塞尔曲线设置一下带圆角的圆角矩形，然后对图片进行裁剪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let path &#x3D; UIBezierPath(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                roundedRect: rect,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                byRoundingCorners: corners.uiRectCorner,&#x2F;&#x2F;此参数表示是哪个圆角</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                cornerRadii: CGSize(width: radius, height: radius)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">context.addPath(path.cgPath)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">context.clip()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">image.draw(in: rect)</span></pre></td></tr></table></figure>

<h5 id="2-6-TintImageProcessor"><a href="#2-6-TintImageProcessor" class="headerlink" title="2.6 TintImageProcessor"></a>2.6 TintImageProcessor</h5><p>用颜色给图像主色，实现方式是利用 CoreImage 中的 CIFilter，使用了这 2 个<code>CIFilter(name: &quot;CIConstantColorGenerator&quot;)</code>和<code>CIFilter(name: &quot;CISourceOverCompositing&quot;)</code></p>
<h5 id="2-7-ColorControlsProcessor"><a href="#2-7-ColorControlsProcessor" class="headerlink" title="2.7 ColorControlsProcessor"></a>2.7 ColorControlsProcessor</h5><p>修改图片的对比度，曝光度，亮度，饱和度，实现方式是利用 CoreImage 中的 CIFilter，使用了这 2 个<code>CIColorControls</code>和<code>CIExposureAdjust</code></p>
<h5 id="2-8-BlackWhiteProcessor"><a href="#2-8-BlackWhiteProcessor" class="headerlink" title="2.8 BlackWhiteProcessor"></a>2.8 BlackWhiteProcessor</h5><p>使图像灰度化，是 ColorControlsProcessor 的特例</p>
<h5 id="2-9-CroppingImageProcessor"><a href="#2-9-CroppingImageProcessor" class="headerlink" title="2.9 CroppingImageProcessor"></a>2.9 CroppingImageProcessor</h5><p>对图片进行裁剪</p>
<h5 id="2-10-DownsamplingImageProcessor"><a href="#2-10-DownsamplingImageProcessor" class="headerlink" title="2.10 DownsamplingImageProcessor"></a>2.10 DownsamplingImageProcessor</h5><p>对图片下采样，一般在较小的 imageView 展示较大的高清图<br>核心实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public static func downsampledImage(data: Data, to pointSize: CGSize, scale: CGFloat) -&gt; KFCrossPlatformImage? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    let imageSourceOptions &#x3D; [kCGImageSourceShouldCache: false] as CFDictionary</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    guard let imageSource &#x3D; CGImageSourceCreateWithData(data as CFData, imageSourceOptions) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    let maxDimensionInPixels &#x3D; max(pointSize.width, pointSize.height) * scale</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    let downsampleOptions &#x3D; [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceShouldCacheImmediately: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceCreateThumbnailWithTransform: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    guard let downsampledImage &#x3D; CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    return KingfisherWrapper.image(cgImage: downsampledImage, scale: scale, refImage: nil)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="2-11-GeneralProcessor"><a href="#2-11-GeneralProcessor" class="headerlink" title="2.11 GeneralProcessor"></a>2.11 GeneralProcessor</h5><p>用于组合多个已有的 Processor，使用方式如下，最终都会转成 GeneralProcessor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用方式1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let processor1 &#x3D; BlurImageProcessor(blurRadius: 5)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let processor2 &#x3D; RoundCornerImageProcessor(cornerRadius: 20)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">let generalProcessor &#x3D; GeneralProcessor(identifier: &quot;123&quot;) &#123; (item, options) -&gt; KFCrossPlatformImage? in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   if let image &#x3D; processor1.process(item: item, options: options) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       return processor2.process(item: .image(image), options: options)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用方式2，此方法是Processor的扩展</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">let generalProcessor &#x3D; BlurImageProcessor(blurRadius: 5).append(RoundCornerImageProcessor(cornerRadius: 20)_</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用方式3，自定义的操作符，调用了append方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">let generalProcessor &#x3D; BlurImageProcessor(blurRadius: 5) |&gt; RoundCornerImageProcessor(cornerRadius: 20)</span></pre></td></tr></table></figure>

<h5 id="2-12-自定义-Processor"><a href="#2-12-自定义-Processor" class="headerlink" title="2.12 自定义 Processor"></a>2.12 自定义 Processor</h5><p>参考<a href="https://juejin.im/post/5de918b86fb9a01626644aae" target="_blank" rel="noopener">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></p>
<h3 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3 缓存"></a>3 缓存</h3><h5 id="3-1-使用自定义的-cacheKey"><a href="#3-1-使用自定义的-cacheKey" class="headerlink" title="3.1 使用自定义的 cacheKey"></a>3.1 使用自定义的 cacheKey</h5><p>通常情况下，会直接通过 URL 去加载图片，这个时候 cacheKey 是 URL.absoluteString，也可使用 ImageResource 自定义 cacheKey</p>
<h5 id="3-2-通过-cacheKey-判断是否缓存，以及缓存的类型"><a href="#3-2-通过-cacheKey-判断是否缓存，以及缓存的类型" class="headerlink" title="3.2 通过 cacheKey 判断是否缓存，以及缓存的类型"></a>3.2 通过 cacheKey 判断是否缓存，以及缓存的类型</h5><p>cacheType 是一个枚举，有三个 case:.none 未缓存,.memory 存在内存缓存,.disk 存在磁盘缓存。<br>需要说明的是 cacheKey+processor.identifier 才是缓存的唯一标识符,只是 DefaultImageProcessor 的 identifier 为空字符串，若是在加载的时候指定了非 DefaultImageProcessor 的 Processor，则在查找的时候需要指定 processorIdentifier</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let cache &#x3D; ImageCache.default</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let isCached &#x3D; cache.isCached(forKey: cacheKey)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let cacheType &#x3D; cache.imageCachedType(forKey: cacheKey)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 若是指定了Processor，可使用此方法查找缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cache.isCached(forKey: cacheKey, processorIdentifier: processor.identifier)</span></pre></td></tr></table></figure>

<h5 id="3-3-通过-cacheKey，从缓存中获取图片"><a href="#3-3-通过-cacheKey，从缓存中获取图片" class="headerlink" title="3.3 通过 cacheKey，从缓存中获取图片"></a>3.3 通过 cacheKey，从缓存中获取图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.retrieveImage(forKey: &quot;cacheKey&quot;) &#123; result in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    switch result &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    case .success(let value):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        print(value.cacheType)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        print(value.image)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    case .failure(let error):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        print(error)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="3-4-设置缓存的配置"><a href="#3-4-设置缓存的配置" class="headerlink" title="3.4 设置缓存的配置"></a>3.4 设置缓存的配置</h5><h6 id="3-4-1-设置内存缓存的容量限制（默认值设置物理内存的四分之一）"><a href="#3-4-1-设置内存缓存的容量限制（默认值设置物理内存的四分之一）" class="headerlink" title="3.4.1 设置内存缓存的容量限制（默认值设置物理内存的四分之一）"></a>3.4.1 设置内存缓存的容量限制（默认值设置物理内存的四分之一）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.memoryStorage.config.totalCostLimit &#x3D; 100 * 1024 * 1024</span></pre></td></tr></table></figure>

<h6 id="3-4-2-设置内存缓存的个数限制"><a href="#3-4-2-设置内存缓存的个数限制" class="headerlink" title="3.4.2 设置内存缓存的个数限制"></a>3.4.2 设置内存缓存的个数限制</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.memoryStorage.config.countLimit &#x3D; 150</span></pre></td></tr></table></figure>

<h6 id="3-4-3-设置内存缓存的过期时间（默认值是-300-秒）"><a href="#3-4-3-设置内存缓存的过期时间（默认值是-300-秒）" class="headerlink" title="3.4.3 设置内存缓存的过期时间（默认值是 300 秒）"></a>3.4.3 设置内存缓存的过期时间（默认值是 300 秒）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.memoryStorage.config.expiration &#x3D; .seconds(300)</span></pre></td></tr></table></figure>

<p>也可指定某一个图片的内存缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options:[.memoryCacheExpiration(.never)])</span></pre></td></tr></table></figure>

<h6 id="3-4-4-设置内存缓存的过期时间更新策略"><a href="#3-4-4-设置内存缓存的过期时间更新策略" class="headerlink" title="3.4.4 设置内存缓存的过期时间更新策略"></a>3.4.4 设置内存缓存的过期时间更新策略</h6><p>更新策略是一个枚举，有三个 case,<code>.none</code> 过期时间不更新,<code>.cacheTime</code> 在当前时间上加上过期时间,<code>.expirationTime(_ expiration: StorageExpiration)</code>过期时间更新为指定多久之后过期。默认值是<code>.cacheTime</code>，使用方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options:[.memoryCacheAccessExtendingExpiration(.cacheTime)])</span></pre></td></tr></table></figure>

<h6 id="3-4-5-设置内存缓存清除过期内存的时间间隔（此值是不可变的，只可在初始化时赋值）"><a href="#3-4-5-设置内存缓存清除过期内存的时间间隔（此值是不可变的，只可在初始化时赋值）" class="headerlink" title="3.4.5 设置内存缓存清除过期内存的时间间隔（此值是不可变的，只可在初始化时赋值）"></a>3.4.5 设置内存缓存清除过期内存的时间间隔（此值是不可变的，只可在初始化时赋值）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.memoryStorage.config.cleanInterval &#x3D; 120</span></pre></td></tr></table></figure>

<h6 id="3-4-6-设置磁盘缓存的容量"><a href="#3-4-6-设置磁盘缓存的容量" class="headerlink" title="3.4.6 设置磁盘缓存的容量"></a>3.4.6 设置磁盘缓存的容量</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.diskStorage.config.sizeLimit &#x3D;  &#x3D; 500 * 1024 * 1024</span></pre></td></tr></table></figure>

<h6 id="3-4-7-设置磁盘缓存的过期时间和过期时间更新策略"><a href="#3-4-7-设置磁盘缓存的过期时间和过期时间更新策略" class="headerlink" title="3.4.7 设置磁盘缓存的过期时间和过期时间更新策略"></a>3.4.7 设置磁盘缓存的过期时间和过期时间更新策略</h6><p>同内存缓存</p>
<h5 id="3-5-手动的缓存图片"><a href="#3-5-手动的缓存图片" class="headerlink" title="3.5 手动的缓存图片"></a>3.5 手动的缓存图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let image: UIImage &#x3D; &#x2F;&#x2F;...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cache.store(image, forKey: cacheKey)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓存原始数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">let data: Data &#x3D; &#x2F;&#x2F;...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">let image: UIImage &#x3D; &#x2F;&#x2F;...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cache.store(image, original: data, forKey: cacheKey)</span></pre></td></tr></table></figure>

<h5 id="3-6-清除缓存"><a href="#3-6-清除缓存" class="headerlink" title="3.6 清除缓存"></a>3.6 清除缓存</h5><h6 id="3-6-1-删除指定的缓存"><a href="#3-6-1-删除指定的缓存" class="headerlink" title="3.6.1 删除指定的缓存"></a>3.6.1 删除指定的缓存</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">forKey: cacheKey,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">processorIdentifier: processor.identifier,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">fromMemory: false,&#x2F;&#x2F;是否才能够内存缓存中删除</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">fromDisk: true &#x2F;&#x2F;是否从磁盘缓存中删除)&#123;&#125;</span></pre></td></tr></table></figure>

<h6 id="3-6-2-清空内存缓存，清空过期的内存缓存"><a href="#3-6-2-清空内存缓存，清空过期的内存缓存" class="headerlink" title="3.6.2 清空内存缓存，清空过期的内存缓存"></a>3.6.2 清空内存缓存，清空过期的内存缓存</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清空内存缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cache.clearMemoryCache()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清空过期的内存缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cache.cleanExpiredMemoryCache()</span></pre></td></tr></table></figure>

<h6 id="3-6-3-清空磁盘缓存，清空过期的磁盘缓存和超过磁盘容量限制的缓存"><a href="#3-6-3-清空磁盘缓存，清空过期的磁盘缓存和超过磁盘容量限制的缓存" class="headerlink" title="3.6.3 清空磁盘缓存，清空过期的磁盘缓存和超过磁盘容量限制的缓存"></a>3.6.3 清空磁盘缓存，清空过期的磁盘缓存和超过磁盘容量限制的缓存</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清空磁盘缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cache.clearDiskCache()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 清空过期的磁盘缓存和超过磁盘容量限制的缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cache.cleanExpiredDiskCache()</span></pre></td></tr></table></figure>

<h5 id="3-7-获取磁盘缓存大小"><a href="#3-7-获取磁盘缓存大小" class="headerlink" title="3.7 获取磁盘缓存大小"></a>3.7 获取磁盘缓存大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cache.calculateDiskStorageSize()</span></pre></td></tr></table></figure>

<h3 id="4-下载"><a href="#4-下载" class="headerlink" title="4. 下载"></a>4. 下载</h3><h5 id="4-1-手动下载图片"><a href="#4-1-手动下载图片" class="headerlink" title="4.1 手动下载图片"></a>4.1 手动下载图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let downloader &#x3D; ImageDownloader.default</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">downloader.downloadImage(with: url) &#123; result in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    switch result &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    case .success(let value):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        print(value.image)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    case .failure(let error):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        print(error)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="4-2-在发送请求之前，修改-Request"><a href="#4-2-在发送请求之前，修改-Request" class="headerlink" title="4.2 在发送请求之前，修改 Request"></a>4.2 在发送请求之前，修改 Request</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个requestModifier</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let modifier &#x3D; AnyModifier &#123; request in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    var r &#x3D; request</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    r.setValue(&quot;abc&quot;, forHTTPHeaderField: &quot;Access-Token&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return r</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在手动下载时设置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">downloader.downloadImage(with: url, options: [.requestModifier(modifier)]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在imageView的setImage的options里设置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, options: [.requestModifier(modifier)])</span></pre></td></tr></table></figure>

<h5 id="4-3-设置超时时间"><a href="#4-3-设置超时时间" class="headerlink" title="4.3 设置超时时间"></a>4.3 设置超时时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">downloader.downloadTimeout &#x3D; 60</span></pre></td></tr></table></figure>

<h5 id="4-4-处理重定向"><a href="#4-4-处理重定向" class="headerlink" title="4.4 处理重定向"></a>4.4 处理重定向</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个重定向的处理逻辑</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let anyRedirectHandler &#x3D; AnyRedirectHandler &#123; (task, resp, req, completionHandler) in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        completionHandler(req)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在手动下载时设置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">downloader.downloadImage(with: url, options: [.redirectHandler(anyRedirectHandler)])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在imageView的setImage的options里设置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url,  options: [.redirectHandler(anyRedirectHandler)])</span></pre></td></tr></table></figure>

<h5 id="4-5-取消下载"><a href="#4-5-取消下载" class="headerlink" title="4.5 取消下载"></a>4.5 取消下载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取消手动下载</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let task &#x3D; downloader.downloadImage(with: url) &#123; result in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">task?.cancel()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取消imageView的下载</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">let task &#x3D; imageView.kf.set(with: url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">task?.cancel()</span></pre></td></tr></table></figure>

<h3 id="5-预加载"><a href="#5-预加载" class="headerlink" title="5. 预加载"></a>5. 预加载</h3><p>使用方式如下，具体可参考<a href="https://juejin.im/post/5dea2640f265da33f03018a0" target="_blank" rel="noopener">Kingfisher 源码解析之 ImagePrefetcher</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let urls &#x3D; [&quot;https:&#x2F;&#x2F;example.com&#x2F;image1.jpg&quot;, &quot;https:&#x2F;&#x2F;example.com&#x2F;image2.jpg&quot;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">           .map &#123; URL(string: $0)! &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let prefetcher &#x3D; ImagePrefetcher(urls: urls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">prefetcher.start()</span></pre></td></tr></table></figure>

<h3 id="7-一些有用的-options"><a href="#7-一些有用的-options" class="headerlink" title="7. 一些有用的 options"></a>7. 一些有用的 options</h3><ul>
<li>loadDiskFileSynchronously 从磁盘中加载时，是否同步的去加载</li>
<li>onlyFromCache 是否只从缓存中加载</li>
<li>cacheMemoryOnly 是否只使用内存缓存</li>
<li>forceRefresh 是否强制刷新，若值为 true，则每次都会重新下载</li>
<li>backgroundDecode 是否在子线程去解码</li>
<li>…其他配置请参考<a href="https://juejin.im/post/5de3cb89e51d45252f3b8400" target="_blank" rel="noopener">Kingfisher 源码解析之 Options 解释</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/%E9%98%85%E8%AF%BBKingfisher%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/07/%E9%98%85%E8%AF%BBKingfisher%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/" class="post-title-link" itemprop="url">阅读Kingfisher源码的一些收获</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-07T00:00:00+08:00">2019-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://user-gold-cdn.xitu.io/2019/12/7/16ee0ebe996bc73d?w=1798&h=890&f=png&s=158996" alt=""></p>
<h4 id="1-命名空间的使用"><a href="#1-命名空间的使用" class="headerlink" title="1. 命名空间的使用"></a>1. 命名空间的使用</h4><p>Kingfisher 命名空间有 2 种方式，一种是使用协议加上包装器，另一种是把类型定义在枚举里。参考协议<code>KingfisherCompatible</code>和类型<code>public enum MemoryStorage {}</code>,一个是空协议，扩展了一个 kf 计算属性，但 kf 里又有个 base 指向自己，另一个是空枚举，定义了带有自己命名空间的类型，<code>Alamofire5.0</code>中使用就是第二种</p>
<h4 id="2-对枚举的了解"><a href="#2-对枚举的了解" class="headerlink" title="2. 对枚举的了解"></a>2. 对枚举的了解</h4><p>Kingfisher 使用了大量的枚举，我以前以为枚举就是为了区分状态，以提高代码的可读性，现在的理解是枚举定义了含义相同，但行为策略可能不同的一组值，比如<code>KingfisherOptionsInfoItem</code>定义了 Kingfisher 的各种配置，但每种配置的意义可能完全不相同，但都是配置，再<code>ExpirationExtending</code>定义了如何更新过期时间，</p>
<h4 id="3-协议对提高扩展性的重要作用"><a href="#3-协议对提高扩展性的重要作用" class="headerlink" title="3. 协议对提高扩展性的重要作用"></a>3. 协议对提高扩展性的重要作用</h4><p>协议是定义了某种能力，由协议遵循者去实现这些能力，但是由于 Swift 中协议扩展的存在，就可以让协议自己就提供某些能力，只要让协议遵循者去遵循协议，就能自动获取这些能力，减少了遵循协议的复杂性。并且协议仅仅定义了某种能力，不涉及具体类型，更方面的去扩展。我比较喜欢的协议又<code>Resource</code>，<code>Placeholder</code>,<code>Processor</code></p>
<h4 id="4-OptionSet-的使用"><a href="#4-OptionSet-的使用" class="headerlink" title="4. OptionSet 的使用"></a>4. OptionSet 的使用</h4><p>OptionSet 类似于 OC 的按位枚举，OptionSet 遵循了 RawRepresentable，需要提供了 rawValue 值，OptionSet 还遵循了 SetAlgebra 可以很方便的数组字面量进行赋值，我比较喜欢这个特性，第一次看到这么写<code>public static let all: RectCorner = [.topLeft, .topRight, .bottomLeft, .bottomRight]</code>，还挺迷糊的，怎么能把一个数组赋值结构体呢</p>
<h4 id="5-加载高清大图的加载"><a href="#5-加载高清大图的加载" class="headerlink" title="5. 加载高清大图的加载"></a>5. 加载高清大图的加载</h4><p>高清大图如果直接加载，会占用较高的内存，为了减少内存的加载，可以使用下采样进行加载高清大图，这也是 Kingfisher 的 demo 中展示高清图的方式，这种方式有个弊端，就是如果我们需要对高清图进行方法展示的，可能会变的模糊，这时候可使用<code>CATiledLayer</code>展示高清图，它可分段绘制</p>
<h4 id="6-加载-GIF-的-2-中方式"><a href="#6-加载-GIF-的-2-中方式" class="headerlink" title="6. 加载 GIF 的 2 中方式"></a>6. 加载 GIF 的 2 中方式</h4><ol>
<li>从 GIF 图中获取所有的图片，利用 UIImage.animateImage()生成一个动图，赋值给 UIImageView</li>
<li>自定义 ImageView 继承自 UIImageView，实现一个定时器根据相应的时间，展示 GIF 图对应的那一帧图片</li>
</ol>
<h4 id="7-判断图片格式的原理"><a href="#7-判断图片格式的原理" class="headerlink" title="7. 判断图片格式的原理"></a>7. 判断图片格式的原理</h4><p>一般图片格式的都在 data 的前几个字节里，只要按对应的规则去取，然后进行判断就行了</p>
<h4 id="8-在子线程对图片进行解码"><a href="#8-在子线程对图片进行解码" class="headerlink" title="8. 在子线程对图片进行解码"></a>8. 在子线程对图片进行解码</h4><p>在子线程对图片进行解码就是在子线程里把 UIImage 里画到一个画布上，从画布上取出画好的图片</p>
<h4 id="9-defer-对提升代码简洁的帮助"><a href="#9-defer-对提升代码简洁的帮助" class="headerlink" title="9. defer 对提升代码简洁的帮助"></a>9. defer 对提升代码简洁的帮助</h4><p>从下图中可看到 context 创建了 2 此，需要释放 2 次，释放只能在绘画之后才能释放，如果不用 defer，你会怎么写<br><img src="https://user-gold-cdn.xitu.io/2019/12/7/16ee0ec2f6961ae4?w=918&h=287&f=png&s=94280" alt=""></p>
<h4 id="10-Kingfisher-使用方式如此简单，但也很方面的进行很多设置"><a href="#10-Kingfisher-使用方式如此简单，但也很方面的进行很多设置" class="headerlink" title="10. Kingfisher 使用方式如此简单，但也很方面的进行很多设置"></a>10. Kingfisher 使用方式如此简单，但也很方面的进行很多设置</h4><p>这里是因为对于每个配置项都有一个默认值或者对配置项为 nil 做了默认处理。这里还想说一下，我们在配置 options 的时候，options 的类型是<code>public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</code>,Kingfisher 中真正用的时候是结构体<code>KingfisherParsedOptionsInfo</code> ,由于配置项属性太多，直接使用结构体，初始化结构体的时候不方便，而使用数组，再通过遍历生成<code>KingfisherParsedOptionsInfo</code>，会方便很多，为喵神的细节处理点赞</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/" class="post-title-link" itemprop="url">Kingfisher源码解析之ImagePrefetcher</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-06T00:00:00+08:00">2019-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<h3 id="ImagePrefetcher-提供了哪些功能"><a href="#ImagePrefetcher-提供了哪些功能" class="headerlink" title="ImagePrefetcher 提供了哪些功能"></a>ImagePrefetcher 提供了哪些功能</h3><p>ImagePrefetcher 是 Kingfisher 提供预加载功能的一个类，提供了一下功能</p>
<ul>
<li>start():开启预加载</li>
<li>stop():停止预加载</li>
<li>maxConcurrentDownloads：设置最大缓存并发量</li>
<li>progressBlock 和 progressSourceBlock：缓存进度的回调</li>
<li>completionHandler 和 completionSourceHandler：缓存结束的回调</li>
</ul>
<h3 id="ImagePrefetcher-预加载的流程图"><a href="#ImagePrefetcher-预加载的流程图" class="headerlink" title="ImagePrefetcher 预加载的流程图"></a>ImagePrefetcher 预加载的流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/6/16edaa5d3ba33b05?w=1154&h=1614&f=png&s=386461" alt="ImagePrefetcher预加载的流程图"></p>
<h3 id="ImagePrefetcher-两个问题"><a href="#ImagePrefetcher-两个问题" class="headerlink" title="ImagePrefetcher 两个问题"></a>ImagePrefetcher 两个问题</h3><h6 id="当调用-stop-函数之后的逻辑"><a href="#当调用-stop-函数之后的逻辑" class="headerlink" title="当调用 stop()函数之后的逻辑"></a>当调用 stop()函数之后的逻辑</h6><p>先来看下 stop 函数的实现，实现比较简单，在预加载的队列里异步的执行把标志位 stopped 设置为 true，并且取消当前所有未完成的下载任务，看起来很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public func stop() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    pretchQueue.async &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        if self.finished &#123; return &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.stopped &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        self.tasks.values.forEach &#123; $0.cancel() &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是 stopped 这个标志位只在网络请求结束的回调里去判断了，这就会发生一些歧义，交给读者去判断 Kingfisher 这么做是否是合理的？当调用 stop 函数时，会出现以下几种情况以及对应的结果</p>
<ol>
<li>调用 stop 时，已经预加载结束了，由于已经结束，会直接返回</li>
<li>调用 stop 时，现在已经有正在下载图片的任务了，会取消所所有请求，然后请求就会走结束的回调，在结束的回调里把剩下的未加载的数据放入到失败的数据源的数组中，调用结束回调</li>
<li>调用 stop 时，还没有正在下载的任务，会继续预加载数据，直到结束，或者有一个请求结束</li>
</ol>
<p>对于情况 1 和情况 2 都是合理的，并且是绝大部分都会是情况 1 和情况 2，对于情况 3，调用 stop 时并没有真正的去停止，但是这种情况也是较少出现的。</p>
<p>对于 stop 方法，喵神的注释是这样的</p>
<blockquote>
<p>/// Stops current downloading progress, and cancel any future prefetching activity that might be occuring.</p>
</blockquote>
<h6 id="缓存进度和缓存结束的回调为什么要各有-2-个"><a href="#缓存进度和缓存结束的回调为什么要各有-2-个" class="headerlink" title="缓存进度和缓存结束的回调为什么要各有 2 个"></a>缓存进度和缓存结束的回调为什么要各有 2 个</h6><p>我第一次看代码，就想为什么要有 2 个呢？为什么这么设计呢？这里以缓存进度的回调举例，它们两个的原因是一样的。先来看下定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public typealias PrefetcherProgressBlock &#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -&gt; Void)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">public typealias PrefetcherSourceProgressBlock &#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ((_ skippedSources: [Source], _ failedSources: [Source], _ completedSources: [Source]) -&gt; Void)</span></pre></td></tr></table></figure>

<p>我们发现基本是一样的，只是回调里的参数类型不一样，一个 Resource，另一个 Source。如果你对这 2 个类型比较了解，想必你应该能猜到这么设计的原因了。</p>
<p>Source 是一个枚举，Kingfisher 中为 UIImage 提供数据源用的，定义如下,有 2 个 case，一个是关联了 Resource，另一个关联了 ImageDataProvider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public enum Source &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    case network(Resource)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    case provider(ImageDataProvider)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Resource 是一个协议，定义如下，提供数据源的真正类型之一，一般用于加载网络图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public protocol Resource &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    var cacheKey: String &#123; get &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    var downloadURL: URL &#123; get &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>ImageDataProvider 也是一个协议，定义如下，提供数据源的另一个真正类型，一般用于本地图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public protocol ImageDataProvider &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    var cacheKey: String &#123; get &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    func data(handler: @escaping (Result&lt;Data, Error&gt;) -&gt; Void)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>回答上面的问题，由于我们一般情况下预加载的都是网络图片，因此提供一个方便我们使用的回调，但为了覆盖到所有情况，就提供了 2 个情况的回调，这个在 ImagePrefetcher 的便利初始化方法里我们就能看出来，当使用[URL]（注：在 URL 的扩展里实现了 Resource 协议）或者[Resource]初始化的时候，就使用 PrefetcherProgressBlock，当使用[Source]初始化时，就使用的 PrefetcherSourceProgressBlock</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/" class="post-title-link" itemprop="url">Kingfisher源码解析之Processor和CacheSerializer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<p>本篇文章主要介绍 Processor 和 CacheSerializer 的基本定义和调用时机，以及利用二者扩展 Kingfisher 以支持 webp 格式的图片</p>
<h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><h5 id="Processor-介绍"><a href="#Processor-介绍" class="headerlink" title="Processor 介绍"></a>Processor 介绍</h5><p>Kingfisher 中 Processor 是一个协议，定义了对原始数据进行加工处理转换成 UIImage 的能力（Kingfisher 缓存的是处理成功之后的 UIImage，根据 options 的值来决定是否缓存原始数据）。<br>这里的原始数据是指 ImageProcessItem，它是一个枚举类型。Processor 和 ImageProcessItem 定义如下，都是特别简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public enum ImageProcessItem &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    case image(KFCrossPlatformImage)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    case data(Data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">public protocol ImageProcessor &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;标识符，在缓存的时候用到，用于区分原始数据和处理加工之后的数据的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    var identifier: String &#123; get &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;交给具体的实现类去实现，ImageProcessItem，最终返回一个UIImage</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="关于-Processor-的两个问题"><a href="#关于-Processor-的两个问题" class="headerlink" title="关于 Processor 的两个问题"></a>关于 Processor 的两个问题</h5><p>如果你了解过 Kingfisher，请尝试回答下这 2 个问题</p>
<ol>
<li>ImageProcessor.process 都在什么时候调用呢？</li>
<li>ImageProcessItem 关联了 2 种类型，一种是 Data，另一种是 UIImage，那么这 2 种类型分别什么时候会用到呢？</li>
</ol>
<p>ImageProcessor.process 在什么时候调用，在调用的时候会传递什么类型的数据？</p>
<ol>
<li>当从网络上下载图片成功之后，会调用 process 把下载成功的 data 加工处理成我们需要的 UIImage。很明显这种情况下传递的是 Data 类型。</li>
<li>当 source 是 ImageDataProvider 时，从 source 中获取到 Data 之后，会调用 process 把 data 加工处理成我们需要的 UIImage。很明显这种情况下传递的也是 Data 类型。</li>
<li>当读取缓存失败，但读取原始数据缓存成功之后，会调用 process 把原始数据加工处理成我们需要的 UIImage。这种情况会先把读取到的 data 使用 cacheSerializer 反序列化为 UIImage，然后传递 UIImage 类型</li>
</ol>
<h3 id="CacheSerializer"><a href="#CacheSerializer" class="headerlink" title="CacheSerializer"></a>CacheSerializer</h3><h5 id="CacheSerializer-介绍"><a href="#CacheSerializer-介绍" class="headerlink" title="CacheSerializer 介绍"></a>CacheSerializer 介绍</h5><p>Kingfisher 中 CacheSerializer 定义了图片序列化和反序列化的能力，也是一个协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public protocol CacheSerializer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    func data(with image: KFCrossPlatformImage, original: Data?) -&gt; Data?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    func image(with data: Data, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="CacheSerializer-的调用时机"><a href="#CacheSerializer-的调用时机" class="headerlink" title="CacheSerializer 的调用时机"></a>CacheSerializer 的调用时机</h5><ol>
<li>当需要磁盘缓存时，会调用<code>func data(with image: KFCrossPlatformImage, original: Data?) -&gt; Data?</code>把 image 序列化成 data，以便写入文件</li>
<li>当从磁盘读取数据时，会调用<code>func image(with data: Data, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage?</code>把 data 反序列化为 UIImage</li>
</ol>
<h3 id="使用-Processor-和-CacheSerializer-扩展-Kingfisher，使-Kingfisher-支持-webP-格式的图片"><a href="#使用-Processor-和-CacheSerializer-扩展-Kingfisher，使-Kingfisher-支持-webP-格式的图片" class="headerlink" title="使用 Processor 和 CacheSerializer 扩展 Kingfisher，使 Kingfisher 支持 webP 格式的图片"></a>使用 Processor 和 CacheSerializer 扩展 Kingfisher，使 Kingfisher 支持 webP 格式的图片</h3><p>Kingfisher 本身是不支持 webp 格式的图片，但是可以利用 Processor 和 CacheSerializer 对 Kingfisher 进行扩展，让 Kingfisher 支持 webP 格式的图片</p>
<blockquote>
<p>WebP 标准是 Google 定制的，迄今为止也只有 Google 发布的 libwebp 实现了该的编解码 。 所以这个库也是该格式的事实标准。</p>
</blockquote>
<p>因此要想支持 webp 格式的图片，需要依赖 libwebp 库，用来实现图片的编码和解码，对于这块的代码我是从<a href="https://github.com/SDWebImage/SDWebImageWebPCoder" target="_blank" rel="noopener">SDWebImageWebPCoder</a>复制过来的，并且去掉了对动图的支持和一些 SD 配置的代码，如果你对这块感兴趣，请参考源码，由于 SD 是 OC 写的，所以这部分我用的也是 OC，最终给 UIImage 添加了一个分类，提供了下面 2 个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@interface UIImage (WebP)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;序列化为Data</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong,readonly,nullable) NSData *webPData;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过data反序列化为UIImage</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">+ (nullable instancetype)imageWithWebPData:(NSData *)webPdata;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@end</span></pre></td></tr></table></figure>

<h5 id="实现-Processor"><a href="#实现-Processor" class="headerlink" title="实现 Processor"></a>实现 Processor</h5><p>在 process 判断 item 的类型，若是 image 则直接返回，若是 data 则反序列化为 UIImage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public struct WebPProcessor: ImageProcessor &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    public static let &#96;default&#96; &#x3D; WebPProcessor()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public let identifier &#x3D; &quot;WebPProcessor&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    public init() &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        switch item &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        case .image(let image):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            return image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        case .data(let data):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            return UIImage(webPData: data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="CacheSerializer-1"><a href="#CacheSerializer-1" class="headerlink" title="CacheSerializer"></a>CacheSerializer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public struct WebPCacheSerializer: CacheSerializer &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    public static let &#96;default&#96; &#x3D; WebPCacheSerializer()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    private init() &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public func data(with image: KFCrossPlatformImage, original: Data?) -&gt; Data? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        return image.webPData;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    public func image(with data: Data, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        return UIImage(webPData: data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if let url &#x3D; URL(string:&quot;http:&#x2F;&#x2F;q21556z4z.bkt.clouddn.com&#x2F;123.webp?e&#x3D;1575537931&amp;token&#x3D;7n8bncOpnUSrN4mijeEAJRdVXnC-jm-mk5qTjKjR:L1_MWy3xugv9ct6PD294CHzwiSE&#x3D;&amp;attname&#x3D;&quot;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    imageView.kf.setImage(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        with: url,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        options: [.processor(WebPProcessor.default), .cacheSerializer(WebPCacheSerializer.default)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>虽说上面的代码都比较简单，但是我感觉 Kingfisher 的这个设计真的挺好的，可扩展支持任意类型的图片，并且 Processor 是用来加工处理图片的，能做的还有其他方面，比如 Kingfisher 中提供了多种实现类，比如圆角的 RoundCornerImageProcessor，显示高清图的 DownsamplingImageProcessor，组装多种 Processor 的 GeneralProcessor。<br><a href="https://github.com/lkkwxy/webpDemo" target="_blank" rel="noopener">demo 地址</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/SDWebImage/SDWebImageWebPCoder" target="_blank" rel="noopener">SDWebImageWebPCoder</a><br><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="noopener">移动端图片格式调研</a><br><a href="https://developers.google.com/speed/webp/" target="_blank" rel="noopener">libwebp 地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/" class="post-title-link" itemprop="url">Kingfisher源码解析之ImageCache</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-04T00:00:00+08:00">2019-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<p>Kingfisher 中 ImageCache 里提供内存缓存和磁盘缓存，分别是<code>MemoryStorage.Backend&lt;KFCrossPlatformImage&gt;</code>和<code>DiskStorage.Backend&lt;Data&gt;</code>来实现的，注：内存缓存和磁盘缓存都是通过<code>class Backend</code>,不过这 2 个类，是完全不同的类，使用枚举来充当命名空间来区分的，分别定义在<code>MemoryStorage.swift</code>和<code>DiskStorage.swift</code>中</p>
<h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>内存缓存一共有三个类构成，<code>Backend</code>提供缓存的功能，<code>Config</code>提供缓存的配置项，<code>StorageObject&lt;T&gt;</code>缓存的封装类型</p>
<h5 id="Config的主要内容"><a href="#Config的主要内容" class="headerlink" title="Config的主要内容"></a><code>Config</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public struct Config &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;内存缓存的最大容量，ImageCache.default中提供的默认值是设备物理内存的四分之一</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public var totalCostLimit: Int</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;内存缓存的最大长度</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public var countLimit: Int &#x3D; .max</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;内存缓存的的过期时长</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    public var expiration: StorageExpiration &#x3D; .seconds(300)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;清除过期缓存的时间间隔</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    public let cleanInterval: TimeInterval</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="StorageObject-lt-T-gt-的主要内容"><a href="#StorageObject-lt-T-gt-的主要内容" class="headerlink" title="StorageObject&lt;T&gt;的主要内容"></a><code>StorageObject&lt;T&gt;</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">class StorageObject&lt;T&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;缓存的真正的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      let value: T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;存活时间，也就是多久之后过期</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      let expiration: StorageExpiration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;缓存e的key</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      let key: String</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;过期时间，默认值是当前时间加上expiration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      private(set) var estimatedExpiration: Date</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 更新过期时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      func extendExpiration(_ extendingExpiration: ExpirationExtending &#x3D; .cacheTime) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">          switch extendingExpiration &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">          case .none:&#x2F;&#x2F;不更新过期时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">              return</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">          case .cacheTime:&#x2F;&#x2F;把过期时间设置为当前时间加上存活时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">              self.estimatedExpiration &#x3D; expiration.estimatedExpirationSinceNow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">          case .expirationTime(let expirationTime):&#x2F;&#x2F;把过期时间设置为指定时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">              self.estimatedExpiration &#x3D; expirationTime.estimatedExpirationSinceNow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 是否已经过期</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      var expired: Bool &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">          &#x2F;&#x2F;estimatedExpiration.isPast 是对Date的一个扩展方法，判断estimatedExpiration是否小于当前时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">          return estimatedExpiration.isPast</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="Backend的主要内容"><a href="#Backend的主要内容" class="headerlink" title="Backend的主要内容"></a><code>Backend</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public class Backend&lt;T: CacheCostCalculable&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;使用NSCache进行缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    let storage &#x3D; NSCache&lt;NSString, StorageObject&lt;T&gt;&gt;()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;存放所有缓存的key，在删除过期缓存是有用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    var keys &#x3D; Set&lt;String&gt;()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;定时器，用于定时清除过期数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    private var cleanTimer: Timer? &#x3D; nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;配置项</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    public var config: Config</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ...下面还有一些缓存数据，读取数据，删除缓存，是否已缓存，删除过期数据等方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由上面我们可以看出，Kingfisher 中内存缓存是用 NSCache 实现的，NSCache 是一个类似于 Dictionary 的类，拥有相似的 API，不过区别于 Dictionary 的是，NSCache 是线程安全的，并且提供了设置最大缓存个数和最大缓存大小的配置，Backend 就是通过设置 NSCache 的<code>countLimit</code>和<code>totalCostLimit</code>来实现最大缓存个数和最大缓存大小。</p>
<p>通过下面的代码，看下 Backend 是如何缓存数据，读取数据，判断是否已缓存，删除缓存，删除过期数据的？代码中有详细的注释，注：下面的代码删除了一些非核心代码，比如异常，加锁保证线程安全等</p>
<h5 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func store(value: T,forKey key: String,expiration: StorageExpiration? &#x3D; nil) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取存活时间，若缓存时没设置，则从配置中获取</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    let expiration &#x3D; expiration ?? config.expiration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断是否过期，若已经过期直接返回</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    guard !expiration.isExpired else &#123; return &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;把要缓存的值封装成StorageObject类型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    let object &#x3D; StorageObject(value, key: key, expiration: expiration)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;把结果缓存起来</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    storage.setObject(object, forKey: key as NSString, cost: value.cacheCost)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;把key保存起来</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    keys.insert(key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="读取数据-判断数据是否已缓存"><a href="#读取数据-判断数据是否已缓存" class="headerlink" title="读取数据,判断数据是否已缓存"></a>读取数据,判断数据是否已缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取数据</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">func value(forKey key: String, extendingExpiration: ExpirationExtending &#x3D; .cacheTime) -&gt; T? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;从NSCache中获取数据，如获取不到直接返回nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    guard let object &#x3D; storage.object(forKey: key as NSString) else &#123; return nil &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断是否过期，若过期直接返回nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    if object.expired &#123; return nil &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;去更新过期时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    object.extendExpiration(extendingExpiration)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    return object.value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断是否缓存，其本质就是去读取数据，只是不更新缓存时间，若取到，则已缓存，否则未缓存</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">func isCached(forKey key: String) -&gt; Bool &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    guard let _ &#x3D; value(forKey: key, extendingExpiration: .none) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        return false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    return true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> func remove(forKey key: String) throws &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    storage.removeObject(forKey: key as NSString)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    keys.remove(key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="删除过期数据，这里使用-Set-存储-key-的原因是-NSCache，并没有像-Dictionary-一样提供获取-allKeys-或-allValues-的方法"><a href="#删除过期数据，这里使用-Set-存储-key-的原因是-NSCache，并没有像-Dictionary-一样提供获取-allKeys-或-allValues-的方法" class="headerlink" title="删除过期数据，这里使用 Set 存储 key 的原因是 NSCache，并没有像 Dictionary 一样提供获取 allKeys 或 allValues 的方法"></a>删除过期数据，这里使用 Set 存储 key 的原因是 NSCache，并没有像 Dictionary 一样提供获取 allKeys 或 allValues 的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func removeExpired() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    for key in keys &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        let nsKey &#x3D; key as NSString</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;通过key获取数据，若获取失败，则删除从keys中删除key</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        guard let object &#x3D; storage.object(forKey: nsKey) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            keys.remove(key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            continue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;判断object是否过期，若过期，则从cache中删除数据，从keys中删除key</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        if object.estimatedExpiration.isPast &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            storage.removeObject(forKey: nsKey)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            keys.remove(key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>Kingfisher 中磁盘缓存是通过文件系统来实现的，也就是说每个缓存的数据都对应一个文件，其中 Kingfisher 把文件的创建时间修改为最后一次读取的时间，把文件的修改时间修改为过期时间。</p>
<p>磁盘缓存一共有三个类构成，<code>Backend</code>提供缓存的功能，<code>Config</code>提供缓存的配置项，<code>FileMeta</code>存储着文件信息。</p>
<h5 id="Config的主要内容-1"><a href="#Config的主要内容-1" class="headerlink" title="Config的主要内容"></a><code>Config</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public struct Config &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;磁盘缓存占用磁盘的最大值，为0z时，表示不限制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public var sizeLimit: UInt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;存活时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public var expiration: StorageExpiration &#x3D; .days(7)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;文件的扩展名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    public var pathExtension: String? &#x3D; nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;是否需要把文件名哈希</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    public var usesHashedFileName &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;操作文件的FileManager</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    let fileManager: FileManager</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;文件缓存所在的文件夹，默认在cache文件夹里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    let directory: URL?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="FileMeta的主要内容"><a href="#FileMeta的主要内容" class="headerlink" title="FileMeta的主要内容"></a><code>FileMeta</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">struct FileMeta &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;文件路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    let url: URL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;文件最后一次读取时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;这个在超过sizeLimit大小时，需要删除文件时，用此属性进行排序，把时间较早的删除掉</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    let lastAccessDate: Date?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;过期时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    let estimatedExpirationDate: Date?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;是否是个文件夹</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    let isDirectory: Bool</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;文件大小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    let fileSize: Int</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="Backend的主要内容-1"><a href="#Backend的主要内容-1" class="headerlink" title="Backend的主要内容"></a><code>Backend</code>的主要内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public class Backend&lt;T: DataTransformable&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;配置信息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    public var config: Config</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;写入文件所在的文件夹，默认在cache文件夹里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    public let directoryURL: URL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;修改文件原信息时，所在的队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    let metaChangingQueue: DispatchQueue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     &#x2F;&#x2F;该方法会在init着调用，保证directoryURLs文件夹，已经被创建过了</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    func prepareDirectory() throws &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        let fileManager &#x3D; config.fileManager</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        let path &#x3D; directoryURL.path</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        guard !fileManager.fileExists(atPath: path) else &#123; return &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        try fileManager.createDirectory(atPath: path,withIntermediateDirectories: true,attributes: nil)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    ...下面还有缓存数据，读取数据，判断是否已缓存，删除缓存，删除过期缓存，删除超过sizeLimit的缓存，统计缓存大小等</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过下面的代码看<code>Backend</code>是如何缓存数据，读取数据，判断是否已缓存，删除缓存，删除过期缓存，删除超过 sizeLimit 的缓存，统计缓存大小以及如何通过 key 生成文件名的？代码中有详细的注释。注：下面的代码删除了一些非核心代码，比如异常，加锁保证线程安全等</p>
<h5 id="通过-key-生成文件名"><a href="#通过-key-生成文件名" class="headerlink" title="通过 key 生成文件名"></a>通过 key 生成文件名</h5><p>下面那段代码和源码中不太一样，但逻辑是一样的，我改成这样是因为方面我描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;首先判断是否使用key的MD5值当做文件名，若是，则把filename设置成key.MD5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;然后再判断是否设置了扩展名，若设置了，则把扩展名拼接到filename上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">func cacheFileName(forKey key: String) -&gt; String &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    var filename &#x3D; key</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    if config.usesHashedFileName &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        filename &#x3D; key.kf.md5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    if let ext &#x3D; config.pathExtension &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        filename &#x3D;  &quot;\(filename).\(ext)&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    return filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="缓存数据-1"><a href="#缓存数据-1" class="headerlink" title="缓存数据"></a>缓存数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func store(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    value: T,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    forKey key: String,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    expiration: StorageExpiration? &#x3D; nil) throws</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取存活时间，若缓存时没设置，则从配置中获取</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    let expiration &#x3D; expiration ?? config.expiration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     &#x2F;&#x2F;判断是否过期，若已经过期直接返回</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    guard !expiration.isExpired else &#123; return &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 把value转成data，这里value类型是DataTransformable，需要实现toData等其他方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    let data: try value.toData()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;通过cacheKeyc生成一个完整的路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;完整的路径等于directoryURL+filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    let fileURL &#x3D; cacheFileURL(forKey: key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    let now &#x3D; Date()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;把当前时间设置为文件的创建时间，把过期时间设置为文件的修改时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    let attributes: [FileAttributeKey : Any] &#x3D; [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        .creationDate: now.fileAttributeDate,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;通过fileManager把data写入文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    config.fileManager.createFile(atPath: fileURL.path, contents: data, attributes: attributes)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中给文件设置创建时间和修改时间用的是给 Date 扩展的计算属性 fileAttributeDate，fileAttributeDate 返回的是 Date(timeIntervalSince1970: ceil(timeIntervalSince1970))，也就是说把 date 的秒值向上取整后再转成 date，为什么要这么做呢？作者解释说，date 在内容中实际是一个 double 类型的值，而在 file 的属性中，只接受 Int 类型的值，会默认舍去小数部分，会导致对测试不友好，所以就改成这样了，我不是很理解为什么对测试不友好，难道是会导致提前一会结束过期吗？</p>
<h5 id="加载缓存"><a href="#加载缓存" class="headerlink" title="加载缓存"></a>加载缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func value(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    forKey key: String,&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    referenceDate: Date,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    actuallyLoad: Bool,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    extendingExpiration: ExpirationExtending) throws -&gt; T?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    let fileManager &#x3D; config.fileManager</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;通过cacheKeyc生成一个完整的路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    let fileURL &#x3D; cacheFileURL(forKey: key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    let filePath &#x3D; fileURL.path</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断是否存在该文件是否存在</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    guard fileManager.fileExists(atPath: filePath) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;通过fileURL生成一个FileMeta文件描述信息的类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    let resourceKeys: Set&lt;URLResourceKey&gt; &#x3D; [.contentModificationDateKey, .creationDateKey]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    let meta &#x3D; try FileMeta(fileURL: fileURL, resourceKeys: resourceKeys)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断文件的过期时间是否大于referenceDate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    if meta.expired(referenceDate: referenceDate) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断是否是真的需要去加载数据，比如判断是否已缓存的时候，就不需要真的去加载，只要知道有就好了</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    if !actuallyLoad &#123; return T.empty &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;读取文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    let data &#x3D; try Data(contentsOf: fileURL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    let obj &#x3D; try T.fromData(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;更新文件的描述信息，本质也是为了h更新最后一次的读取时间和过期时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    metaChangingQueue.async &#123; meta.extendExpiration(with: fileManager, extendingExpiration: extendingExpiration) &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="判断是否已缓存"><a href="#判断是否已缓存" class="headerlink" title="判断是否已缓存"></a>判断是否已缓存</h5><p>通过调用 value 方法，判断 value 的返回值是否为 nil，调用时会把 actuallyLoad 参数传为 false，这样就不会去读取文件</p>
<h5 id="通过-key-删除缓存，以及删除所有缓存"><a href="#通过-key-删除缓存，以及删除所有缓存" class="headerlink" title="通过 key 删除缓存，以及删除所有缓存"></a>通过 key 删除缓存，以及删除所有缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过key生成URL，然后把该文件删除</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">func remove(forKey key: String) throws &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    let fileURL &#x3D; cacheFileURL(forKey: key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    config.fileManager.removeItem(at: url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接把文件夹删除</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">func removeAll(skipCreatingDirectory: Bool) throws &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    try config.fileManager.removeItem(at: directoryURL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    if !skipCreatingDirectory &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        try prepareDirectory()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="获取缓存大小"><a href="#获取缓存大小" class="headerlink" title="获取缓存大小"></a>获取缓存大小</h5><p>获取文件夹下的所有文件，并把每个文件的大小加起来</p>
<h5 id="删除过期的缓存"><a href="#删除过期的缓存" class="headerlink" title="删除过期的缓存"></a>删除过期的缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除在指定时间过期的缓存，若传入当前时间，则是删除现在已经过期的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回值：删除的文件路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">func removeExpiredValues(referenceDate: Date &#x3D; Date()) throws -&gt; [URL] &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    let propertyKeys: [URLResourceKey] &#x3D; [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        .isDirectoryKey,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        .contentModificationDateKey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取所有的文件URL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    let urls &#x3D; try allFileURLs(for: propertyKeys)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    let keys &#x3D; Set(propertyKeys)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;过滤出过期的文件URL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    let expiredFiles &#x3D; urls.filter &#123; fileURL in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        let meta &#x3D; FileMeta(fileURL: fileURL, resourceKeys: keys)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        if meta.isDirectory &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            return false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        return meta.expired(referenceDate: referenceDate)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;遍历所有的过期的文件UR，依次删除它们</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    try expiredFiles.forEach &#123; url in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        try removeFile(at: url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    return expiredFiles</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="缓存大小超过-sizeLimit-时删除缓存"><a href="#缓存大小超过-sizeLimit-时删除缓存" class="headerlink" title="缓存大小超过 sizeLimit 时删除缓存"></a>缓存大小超过 sizeLimit 时删除缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func removeSizeExceededValues() throws -&gt; [URL] &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;如果sizeLimit &#x3D;&#x3D; 0代表不限制大小，直接返回</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      if config.sizeLimit &#x3D;&#x3D; 0 &#123; return [] &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      var size &#x3D; try totalSize()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;如果当前的缓存大小小于sizeLimit直接返回</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      if size &lt; config.sizeLimit &#123; return [] &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      let urls &#x3D; 获取所有的URLs</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;通过urls生成所有的文件信息，这里包含的信息有是否是文件夹，创建时间，和文件大小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      var pendings: [FileMeta] &#x3D; urls.compactMap &#123; fileURL in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">          guard let meta &#x3D; try? FileMeta(fileURL: fileURL, resourceKeys: keys) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">              return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">          return meta</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;通过创建时间排序，也就是通过最后一次的读取时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      pendings.sort(by: FileMeta.lastAccessDate)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      var removed: [URL] &#x3D; []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      let target &#x3D; config.sizeLimit &#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F;直到当前缓存大小小于sizeLimit的2分之一，否则按照最后的读取时间一次删除</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      while size &gt; target, let meta &#x3D; pendings.popLast() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          size -&#x3D; UInt(meta.fileSize)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">          try removeFile(at: meta.url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">          removed.append(meta.url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      return removed</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在 ImageCache 里监听了三个通知，分别是收到内存警告，应用即将被杀死，应用已经进入到后台，在这三个通知里分别做了，清空内存缓存，异步的清除磁盘过期缓存和磁盘大小超过 simeLimit 清除缓存，在后台清除磁盘过期缓存和磁盘大小超过 simeLimit 清除缓存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Kingfisher源码解析之加载流程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-04T00:00:00+08:00">2019-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<h4 id="1-当我们调用-imageView-kf-setImage-之后发生了什么"><a href="#1-当我们调用-imageView-kf-setImage-之后发生了什么" class="headerlink" title="1. 当我们调用 imageView.kf.setImage()之后发生了什么?"></a>1. 当我们调用 imageView.kf.setImage()之后发生了什么?</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/3/16ecc79a6f17e511?w=1114&h=934&f=png&s=148121" alt="当我们调用imageView.kf.setImage()之后发生了什么?"></p>
<h4 id="2-Kingfisher-中图片加载的流程是什么"><a href="#2-Kingfisher-中图片加载的流程是什么" class="headerlink" title="2. Kingfisher 中图片加载的流程是什么?"></a>2. Kingfisher 中图片加载的流程是什么?</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/3/16ecc7a077b91bd2?w=1716&h=1140&f=png&s=263432" alt=" Kingfisher中图片加载的流程是什么?"></p>
<h4 id="3-Kingfisher-是如何缓存图片的"><a href="#3-Kingfisher-是如何缓存图片的" class="headerlink" title="3. Kingfisher 是如何缓存图片的?"></a>3. Kingfisher 是如何缓存图片的?</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/3/16ecc7ae91ab587e?w=818&h=756&f=png&s=193435" alt="Kingfisher是如何缓存图片的?"></p>
<h4 id="4-Kingfisher-是如何查找缓存的"><a href="#4-Kingfisher-是如何查找缓存的" class="headerlink" title="4. Kingfisher 是如何查找缓存的?"></a>4. Kingfisher 是如何查找缓存的?</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/3/16ecc7a483c50dd8?w=1119&h=1051&f=png&s=235927" alt=" Kingfisher是如何查找缓存的?"><br>注：图中有较多的查找失败，加工失败，并且也返回 true，并且返回 true，也不会再重新从网络上加载，但是 Kingfisher 里就是这么处理的，我认为是合理的，首先这种情况发生的情况是极低的，首先在获取之前先去排查了一下，文件是否存在，只有在存在的时候才会去加载，因此查找不到的可能性极低，而加工失败的话，很大可能性是 processor 或者 cacheSerializer 的问题，即使重新下载一遍，很很有可能有问题，除非我们写入文件的数据，在其他地方被动过，但这种可能性也不大</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/" class="post-title-link" itemprop="url">Kingfisher源码解析之加载动图</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-02T00:00:00+08:00">2019-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<h3 id="Kingfisher-加载-GIF-的两种使用方式"><a href="#Kingfisher-加载-GIF-的两种使用方式" class="headerlink" title="Kingfisher 加载 GIF 的两种使用方式"></a>Kingfisher 加载 GIF 的两种使用方式</h3><ol>
<li><p>使用 UIImageView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let imageView &#x3D; UIImageView()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: URL(string: &quot;gif_url&quot;)!)</span></pre></td></tr></table></figure></li>
<li><p>使用 AnimatedImageView，AnimatedImageView 继承自 UIImageView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let imageView &#x3D; AnimatedImageView()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: URL(string: &quot;gif_url&quot;)!)</span></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Kingfisher-内部是如何处理的"><a href="#Kingfisher-内部是如何处理的" class="headerlink" title="Kingfisher 内部是如何处理的"></a>Kingfisher 内部是如何处理的</h3><p>看了上面 2 个显示 GIF 的方法，我们可能下面 2 个疑问，如果你对下面 2 个问题很清楚，本篇文章你可以跳过了</p>
<ul>
<li>加载 GIF 图和加载普通图片的使用方式是一样的，它是怎么做到如果是 GIF 图就显示 GIF 图，是普通图片就是现实普通图片的</li>
<li>使用 UIImageView 和 AnimatedImageView 的调用方式也是一样的，这 2 中加载方式是否不同<br>我们先来看第一个问题，Kingfisher 是如何区分 GIF 图和普通图片的,这个问题分 3 种情况</li>
</ul>
<ol>
<li>图片通过 Resource（通过网络下载的）或者 ImageDataProvider 提供的</li>
<li>图片是从缓存中内存缓存中加载的</li>
<li>图片是从磁盘缓存中加载的</li>
</ol>
<p>首先来看第一种情况，在这之前，先来看下<code>Kingfisher</code>中配置项的这个配置<code>public var processor: ImageProcessor = DefaultImageProcessor.default</code>，这个配置是提供网络下载完成或者加载完成本地 Data 之后，会调用<code>processor</code>的<code>func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage?</code>方法，把 Data 转换成 UIImage，而 processor 的默认值是<code>DefaultImageProcessor</code>，在<code>DefaultImageProcessor</code>该方法的实现会调用下面这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public static func image(data: Data, options: ImageCreatingOptions) -&gt; KFCrossPlatformImage? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     var image: KFCrossPlatformImage?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     switch data.kf.imageFormat &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     case .JPEG:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         image &#x3D; KFCrossPlatformImage(data: data, scale: options.scale)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     case .PNG:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">         image &#x3D; KFCrossPlatformImage(data: data, scale: options.scale)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     case .GIF:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">         image &#x3D; KingfisherWrapper.animatedImage(data: data, options: options)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     case .unknown:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">         image &#x3D; KFCrossPlatformImage(data: data, scale: options.scale)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">     return image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>在这个方法里会先判断图片的类型，判断的方式是取 data 的前 8 个字节，感兴趣的话，可以去源码里看下，这里就不贴了，如果是 GIF 图的话<code>KingfisherWrapper.animatedImage</code>这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public static func animatedImage(data: Data, options: ImageCreatingOptions) -&gt; KFCrossPlatformImage? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    let info: [String: Any] &#x3D; [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceShouldCache as String: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        kCGImageSourceTypeIdentifierHint as String: kUTTypeGIF</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    guard let imageSource &#x3D; CGImageSourceCreateWithData(data as CFData, info as CFDictionary) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;这里去掉了Macos下的处理</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    var image: KFCrossPlatformImage?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    if options.preloadAll || options.onlyFirstFrame &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        guard let animatedImage &#x3D; GIFAnimatedImage(from: imageSource, for: info, options: options) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            return nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        if options.onlyFirstFrame &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            image &#x3D; animatedImage.images.first</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            let duration &#x3D; options.duration &lt;&#x3D; 0.0 ? animatedImage.duration : options.duration</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            image &#x3D; .animatedImage(with: animatedImage.images, duration: duration)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        image?.kf.animatedImageData &#x3D; data</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        image &#x3D; KFCrossPlatformImage(data: data, scale: options.scale)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        var kf &#x3D; image?.kf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        kf?.imageSource &#x3D; imageSource</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        kf?.animatedImageData &#x3D; data</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    return image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法时展示 GIF 的核心逻辑，下面详细介绍下这个方法<br>首先把 data 转成 CGImageSource，然后判断<code>options.preloadAll || options.onlyFirstFrame</code> 的值，其中 onlyFirstFrame 默认值为 false，若为 false 则只加载第一帧，preloadAll 这个值，在我们使用<code>imageView.kf.setImage</code>时，则取决于 imageView 的<code>func shouldPreloadAllAnimation()</code>函数的返回值，此函数是 Kingfisher 给 UIImageView 扩展的方法，在 UIImageVIew 中一直返回 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@objc extension KFCrossPlatformImageView &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    func shouldPreloadAllAnimation() -&gt; Bool &#123; return true &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也就是说在默认情况下，在上面的方法里会把<code>imageSource</code>转换成<code>GIFAnimatedImage</code>类的实例，而在这个类的实例里，做了获取 GIF 图的每一帧，并获取每一帧的时间然后加起来，最后通过<code>UIImage.animatedImage(with: [images], duration: duration)</code>生成一个动图的 image 实例，然后把 image 赋值给<code>imageView.image</code></p>
<p>下面把 imageSource 转成 animatedImage 的代码，忽略了较多的异常情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let options: [String: Any] &#x3D; [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    kCGImageSourceShouldCache as String: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    kCGImageSourceTypeIdentifierHint as String:kUTTypeGIF</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;把data转换成imageSource</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">let imageSource &#x3D; CGImageSourceCreateWithData(data as CFData, options as CFDictionary)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取GIF的总帧数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">let frameCount &#x3D; CGImageSourceGetCount(imageSource)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">var images &#x3D; [UIImage]()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">var gifDuration &#x3D; 0.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">for i in 0..&lt;frameCount &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取第i帧的图片，并把图片添加到数组里去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    let cgImage &#x3D; CGImageSourceCreateImageAtIndex(imageSource, i, options as CFDictionary)!</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    images.append( UIImage(cgImage: cgImage, scale: 1, orientation: .up))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;若只有一帧，把动画时间设置成无限大，否则的话获取每一帧的时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    if frameCount &#x3D;&#x3D; 1 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        gifDuration &#x3D; Double.infinity</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;获取每一帧的属性，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        let properties &#x3D; CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as! [String: Any]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;获取属性中的GIF信息，以及获取信息中的时间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        let gifInfo &#x3D; properties[kCGImagePropertyGIFDictionary as String] as! [String: Any]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        let unclampedDelayTime &#x3D; gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        let delayTime &#x3D; gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        let duration &#x3D; unclampedDelayTime ?? delayTime</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        gifDuration +&#x3D; duration?.doubleValue ?? 0.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">imageView.image &#x3D; UIImage.animatedImage(with: images, duration: gifDuration)</span></pre></td></tr></table></figure>

<p>接着看第二种情况，若是从内存缓存中加载的，缓存的就是动图，所以是直接加载的</p>
<p>最后看第三种情况，若是从磁盘中缓存的，Kingfisher 又是如何处理的，在这之前，先来看下<code>Kingfisher</code>中配置项的这个配置<code>public var cacheSerializer: CacheSerializer = DefaultCacheSerializer.default</code>，这个配置是提供当从磁盘中读取完数据之后，把数据反序列化为 UIImage，会调用<code>cacheSerializer</code>的<code>public func image(with data: Data, options: KingfisherParsedOptionsInfo) -&gt; KFCrossPlatformImage?</code>方法，把 Data 反序列化为 UIImage，而 cacheSerializer 的默认值是<code>DefaultCacheSerializer</code>，在<code>DefaultCacheSerializer</code>该方法的实现也会调用<code>public static func image(data: Data, options: ImageCreatingOptions) -&gt; KFCrossPlatformImage?</code>这个方法，下面就是跟第一种情况的逻辑一样了</p>
<p>下面来看 AnimatedImageView 是如何加载 GIF 图的，上面说 imageView 的<code>shouldPreloadAllAnimation</code>一直返回 true，而 AnimatedImageView 重写了此函数，并返回 false，因此<code>option.preloadAll</code>等于 false，所以会走 else 里的逻辑，把 data 转成 image，利用关联属性，给 image 添加了两个属性<code>imageSource:CGImageSource</code>和<code>animatedImageData:Data</code>，并对其进行赋值</p>
<p>到现在为止，我们还是没有看到 AnimatedImageView 是如何展示 GIF 图的。接着往下看<br>AnimatedImageView 重写了 image 的 didSet，而上面的方法返回后，会对 imageView.image 进行赋值，正好触发了 image 的 didSet，在这里开启了一个 CADisplayLink 和 Animator。</p>
<p>Animator 为 imageView 提供动图的数据，每一帧的图片以及时间，需要注意的是，它并不会一次加载好所有帧的图片，默认情况下，只是先加载前 10 帧，剩下的等需要的再去加载</p>
<p>CADisplayLink，在每次屏幕刷新的时候，去判断是否需要展示新的一帧图片，若需要，则刷新 imageView</p>
<p>这里刷新是调用<code>self.layer.setNeedsDisplay()</code>,而调用此方法，系统会调用<code>layer.delegate</code>里的<code>open func display(_ layer: CALayer)</code>，而 UIView 的 layer.delegate 是自己本身，所以会调用 AnimatedImageView 重写的 display 方法，这是我最开始没有想明白的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">override open func display(_ layer: CALayer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     if let currentFrame &#x3D; animator?.currentFrameImage &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">         layer.contents &#x3D; currentFrame.cgImage</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         layer.contents &#x3D; image?.cgImage</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<h3 id="UIImageView-和-AnimatedImageView-在展示-GIF-图有什么不同"><a href="#UIImageView-和-AnimatedImageView-在展示-GIF-图有什么不同" class="headerlink" title="UIImageView 和 AnimatedImageView 在展示 GIF 图有什么不同"></a>UIImageView 和 AnimatedImageView 在展示 GIF 图有什么不同</h3><p>AnimatedImageView 支持一下 5 点特性，而 UIImageView 都不支持</p>
<ol>
<li><code>repeatCount</code>：循环次数</li>
<li><code>autoPlayAnimatedImage</code>：是否自动开始播放</li>
<li><code>framePreloadCount</code>：预加载的帧数</li>
<li><code>backgroundDecode</code>：是否在后台解码</li>
<li><code>runLoopMode</code>：GIF 播放所在的 runLoopMode</li>
</ol>
<p>并且 AnimatedImageView 由于不用同时解码所有帧的图形数据，所以更节省内存，但是由于多了一些计算所以会比较浪费 CPU</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">Kingfisher源码解析之Options解释</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-01T00:00:00+08:00">2019-12-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kingfisher 源码解析系列，由于水平有限，哪里有错，肯请不吝赐教</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/07/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8/">Kingfisher 源码解析之使用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/01/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BOptions%E8%A7%A3%E9%87%8A/">Kingfisher 源码解析之 Options 解释</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">Kingfisher 源码解析之加载流程</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/02/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8A%A0%E8%BD%BD%E5%8A%A8%E5%9B%BE/">Kingfisher 源码解析之加载动图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/04/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImageCache/">Kingfisher 源码解析之 ImageCache</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/05/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BProcessor%E5%92%8CCacheSerializer/">Kingfisher 源码解析之 Processor 和 CacheSerializer</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="/2019/12/06/Kingfisher%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BImagePrefetcher/">Kingfisher 源码解析之 ImagePrefetcher</a></li>
</ul>
<ol>
<li><p>targetCache,originalCache</p>
<ul>
<li>类型 ImageCache,Kingfisher 中的缓存管理器，提供内存和磁盘缓存</li>
<li>targetCache 最终展示出来的缓存管理器</li>
<li>originalCache 原始数据的缓存管理器</li>
<li>默认值都为 nil，为 nil 时，使用 ImageCache(name: “default”)</li>
</ul>
</li>
<li><p>downloader</p>
<ul>
<li>类型 ImageDownloader，图片下载器，提供图片下载的功能</li>
<li>默认值为 nil，为 nil 时，使用 ImageDownloader(name: “default”)</li>
</ul>
</li>
<li><p>downloadPriority 下载优先级</p>
</li>
<li><p>transition</p>
<ul>
<li>类型 ImageTransition，默认是为 ImageTransition.none</li>
<li>为 imageView 显示 image 的时候提供过渡动画</li>
</ul>
</li>
<li><p>forceTransition</p>
<ul>
<li>类型为 Bool，默认值 false</li>
<li>是否强制使用过渡动画，当值为 true 时，transition 不为.none 时就使用过渡动画，当值为 false 时，只有 transition 不为.none 并且不使用缓存时，才使用缓存动画</li>
</ul>
</li>
<li><p>forceRefresh 是否强制刷新，若值为 true，则不使用缓存</p>
</li>
<li><p>fromMemoryCacheOrRefresh 当值为 true 时，刷新的时候，若使用缓存，则只使用内存缓存，不去磁盘缓存</p>
</li>
<li><p>cacheMemoryOnly 是否只使用内存缓存</p>
</li>
<li><p>waitForCache 是否等待缓存完成，再调用回调</p>
</li>
<li><p>onlyFromCache 是否只从缓存中加载</p>
</li>
<li><p>backgroundDecode 是否在子线程去解码</p>
</li>
<li><p>preloadAllAnimationData</p>
<ul>
<li>是否预加载 GIF 图每一帧画面,默认值为 false</li>
<li>若使用 UIImageView.setImage(),去加载图片，则会被强制设置成 true，因为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> @objc extension UIImageView &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    func shouldPreloadAllAnimation() -&gt; Bool &#123; return true &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> public func setImage(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    with source: Source?,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    placeholder: Placeholder? &#x3D; nil,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    options: KingfisherOptionsInfo? &#x3D; nil ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   -&gt; DownloadTask? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">         ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;若shouldPreloadAllAnimation()的值为true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;则把preloadAllAnimationData设为true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;而ImageView中的shouldPreloadAllAnimation()一直为true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">         if base.shouldPreloadAllAnimation() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            options.preloadAllAnimationData &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>onlyLoadFirstFrame 若图片是 GIF 图时，是否只显示第一帧</p>
</li>
<li><p>callbackQueue,processingQueue</p>
<ul>
<li>callbackQueue,图片处理结束之后，回调所在的队列，默认值 mainCurrentOrAsync</li>
<li>processingQueue，处理图片时所在的队列，比如利用 processor 给图片添加圆角等操作时，所在的队列，默认使用一个串行的子队列</li>
<li>一共有四个值可选择.mainAsync,.mainCurrentOrAsync,.untouch,.dispatch(DispatchQueue)</li>
<li>.mainAsync 主线程中异步执行</li>
<li>.mainCurrentOrAsync，若当前线程是主线程，则直接执行，否则在主线程异步执行</li>
<li>.untouch 不改变当前所在的线程</li>
<li>.dispatch(DispatchQueue) 在指定的队列中执行</li>
</ul>
</li>
<li><p>requestModifier 发送请求时对原始的请求进行修改，返回新的 Request</p>
</li>
<li><p>redirectHandler 当请求发生重定向是，自定义的一些处理</p>
</li>
<li><p>processor 加工者，自定义 data|image 转成 image 的逻辑，</p>
</li>
<li><p>imageModifier image 修饰器，对 image 做一些修改，比如返回 image.withRenderingMode(renderingMode)</p>
</li>
<li><p>cacheSerializer 定义图片序列化和反序列化</p>
</li>
<li><p>keepCurrentImageWhileLoading 当加载一个新图时，是否要保持当前的图片</p>
</li>
<li><p>cacheOriginalImage 是否要缓存原始的数据</p>
</li>
<li><p>onFailureImage 加载失败时，要展示的图片</p>
</li>
<li><p>alsoPrefetchToMemory 预加载时，需要从磁盘加载时，是否也需要同步到内存中</p>
</li>
<li><p>loadDiskFileSynchronously 从磁盘中加载时，是否同步的去加载</p>
</li>
<li><p>memoryCacheExpiration，diskCacheExpiration 设置内存、磁盘缓存过期时间</p>
</li>
<li><p>memoryCacheAccessExtendingExpiration</p>
<ul>
<li>当从内存、磁盘中取图片时，往后延长过期时间的策略</li>
<li>有以下几个值：.none,.cacheTime,.expirationTime(_ expiration: StorageExpiration)</li>
<li>.none 保持原来的过期时间</li>
<li>.cacheTime 设置过期时间为当前时间加上原来的过期时间</li>
<li>.expirationTime(_ expiration: StorageExpiration) 设置过期时间到指定时间</li>
</ul>
</li>
<li><p>alternativeSources 当加载失败时，可供替代的数据源</p>
</li>
<li><p>onDataReceived 接收到数据时，需要回调时，可设置此属性，比如 setImage 时设置的 DownloadProgressBlock，就是在里面封装了此属性</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/14/%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84flex%E5%B8%83%E5%B1%80%E9%81%87%E5%88%B0button%E6%97%B6%EF%BC%8Cjustify-content%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/14/%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84flex%E5%B8%83%E5%B1%80%E9%81%87%E5%88%B0button%E6%97%B6%EF%BC%8Cjustify-content%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-14T00:00:00+08:00">2019-10-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" itemprop="url" rel="index">
                    <span itemprop="name">小程序</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在做小程序的时候，要实现下面的搜索历史界面<br><img src="http://q21556z4z.bkt.clouddn.com/128249-e2c441ef0d2d2f83.png" alt="屏幕快照 2019-10-14 上午10.20.07.png"></p>
<p>下面的搜索很明显的想到是用 flex 布局，然后把 justify-content 设置为 justify-content: flex-start;<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;flex&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;item&quot;&gt;7&lt;&#x2F;button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&lt;!--wxss--&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">.flex&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  display: flex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  flex-wrap: wrap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  justify-content: flex-start;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">.flex .item&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  width: 216rpx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  background-color: red;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  margin-bottom: 34rpx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="http://q21556z4z.bkt.clouddn.com/128249-09c0b5b06355e6fe.png" alt="屏幕快照 2019-10-14 上午10.35.32.png"></p>
<p>可效果却不尽人意，发现 justify-content 不起作用，无论怎么设置都是 space-around 的效果。<br>经过排查，发现原因是小程序 button 中的默认样式中的<code>margin-left: auto;margin-right: auto;</code>所引起的。</p>
<hr>
<blockquote>
<p>flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自<a href="https://github.com/chokcoco/iCSS/issues/64" target="_blank" rel="noopener">探秘 flex 上下文中神奇的自动 margin</a></p>
</blockquote>
<p>原因找到了，具体修改就容易多了，我们可以覆盖 button 的 margin-left 和 margin-right 的默认值，或者在 button 外面包裹一层 view。</p>
<p>在遇到这个问题之前，我也没想到过 flex 和 margin 之间还能这么用，涨姿势了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李坤坤">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李坤坤">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/04/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95%E9%A2%98-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/" class="post-title-link" itemprop="url">剑指Offer算法题-打印从1到最大的n位数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">2018-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>####题目<br>输入数字 n，按顺序打印出从 1 到 n 最大的 n 位十进制数。比如输入 3，则打印 1、2、3 一直到最大的 3 位数 999 ####方案<br>看到题目，首先想到先求出最大的 n 位数(maxN),然后从 1 开始遍历到 maxN.但是这里有个陷进，就是 maxN 有可能超出<code>Int</code>或者<code>long long</code>表示的最大数的范围，这个时候回发生溢出错误。</p>
<p>所以这个时候要选择合适的类型来表示 maxN，我这里选择的是用<code>Array</code>来表示 maxN，最高位放到数组的最前面。以四位数举例，585 可以表示为[0,5,8,5]，</p>
<p>用数组表示 maxN 之后，面临着三个问题：</p>
<ol>
<li><p>输出打印<br>这个时候只需要遍历数组，把前面的 0 去掉即可</p>
</li>
<li><p>加 1<br>对数组进行倒序遍历，对后位进行<code>+1</code>，若结果大于 9，则把该位置 0，继续对前面的数进行<code>+1</code>，若结果不大于 9，则把结果赋值给当前位并停止遍历</p>
</li>
<li><p>何时停止<br>若数组的首位进行进位时，则表示已经遍历了最大值，需要停止循环 ####代码 Swift</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func printOneToMaxOfDigits(digitNumber:Int) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;初始化一个全为0的长度为digitNumber的数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    var array &#x3D; Array(repeating: 0, count: digitNumber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;相当于生成一个从digitNumber-1到0的一个序列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    let strideTo &#x3D; stride(from: digitNumber - 1, to: -1, by: -1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F;对数组进行加1的函数，若返回false则代表已经超出最大值，可以停止了</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    func addOne() -&gt; Bool&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        for index in strideTo &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            if array[index] + 1 &gt; 9 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                array[index] &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                if index &#x3D;&#x3D; 0 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    return false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                array[index] &#x3D; array[index] + 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                break</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        return true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;对数组进行打印</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    func printArray() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        var result &#x3D; &quot;&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        var isAppend &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        for item in array &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            if isAppend || item !&#x3D; 0 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                result +&#x3D; &quot;\(item)&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                isAppend &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        print(result)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;调用加1方法，知道加1方法返回false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    while addOne() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        printArray()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">printOneToMaxOfDigits(digitNumber: 5)</span></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李坤坤</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lkkwxy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lkkwxy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wxylkk@163.com" title="E-Mail → wxylkk@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/p/1005055629872637/home" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;p&#x2F;1005055629872637&#x2F;home" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.im/user/578ecc011532bc0061002f3e" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;578ecc011532bc0061002f3e" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom juejin"></i>掘金</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李坤坤</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
